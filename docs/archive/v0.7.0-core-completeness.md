# v0.7.0-alpha: Core Completeness

**Target:** February 2026  
**Goal:** 85% feature parity with Solid.js (from 75%)  
**Duration:** 4-6 weeks

## Implementation Rules

**CRITICAL - Must Follow:**

- One item per file (class, function, interface, type)
- Prototype-based classes (no class keyword)
- Feature slice architecture (feature/index.ts, feature/prototype/, feature/\*.types.ts)
- All types in separate .types.ts files
- Exports via index.ts only
- JSX via Pulsar runtime (jsxImportSource: "pulsar")

## Features

### 1. Index Component ðŸ”´ CRITICAL

**Priority:** P0  
**Duration:** 1 week

**File Structure:**

```
src/control-flow/index/
â”œâ”€â”€ index.ts              # Exports
â”œâ”€â”€ index-component.ts    # Main Index function
â”œâ”€â”€ index.types.ts        # IIndexProps
â””â”€â”€ README.md             # Documentation
```

**Implementation:**

- Non-keyed iteration (track by array index)
- API: `<Index each={items()}>{(item, index) => ...}</Index>`
- Item wrapped in signal: `() => T`
- Index is number (not signal)
- Handle primitives and objects

**Acceptance Criteria:**

- [ ] Renders list without keys
- [ ] Items are reactive signals
- [ ] Index is stable number
- [ ] Updates only changed items
- [ ] Handles primitives correctly
- [ ] Tests pass (15+ test cases)
- [ ] Documentation complete

---

### 2. Dynamic Component ðŸ”´ CRITICAL

**Priority:** P0  
**Duration:** 1 week

**File Structure:**

```
src/control-flow/dynamic/
â”œâ”€â”€ index.ts                # Exports
â”œâ”€â”€ dynamic-component.ts    # Main Dynamic function
â”œâ”€â”€ dynamic.types.ts        # IDynamicProps
â”œâ”€â”€ resolve-component.ts    # Component resolution logic
â””â”€â”€ README.md               # Documentation
```

**Implementation:**

- Resolve component from string or function
- API: `<Dynamic component={type()} {...props} />`
- Support component registry
- Handle missing components gracefully
- Forward all props

**Acceptance Criteria:**

- [ ] Resolves string component names
- [ ] Accepts function components
- [ ] Props forwarded correctly
- [ ] Handles missing components
- [ ] Re-renders on component change
- [ ] Tests pass (12+ test cases)
- [ ] Documentation complete

---

### 3. reconcile() Utility ðŸ”´ CRITICAL

**Priority:** P0  
**Duration:** 2 weeks

**File Structure:**

```
src/state/reconcile/
â”œâ”€â”€ index.ts              # Exports
â”œâ”€â”€ reconcile.ts          # Main reconcile function
â”œâ”€â”€ reconcile.types.ts    # Types
â”œâ”€â”€ diff-objects.ts       # Object diffing
â”œâ”€â”€ diff-arrays.ts        # Array diffing
â””â”€â”€ README.md             # Documentation
```

**Implementation:**

- Efficient immutable state updates
- API: `setState('users', reconcile(newUsers))`
- Deep comparison algorithm
- Minimize object creation
- Handle nested structures

**Acceptance Criteria:**

- [ ] Diffs objects correctly
- [ ] Diffs arrays correctly
- [ ] Reuses unchanged values
- [ ] Handles nested structures
- [ ] Performance: O(n) for arrays
- [ ] Tests pass (25+ test cases)
- [ ] Documentation with examples

---

### 4. produce() Utility ðŸ”´ CRITICAL

**Priority:** P1  
**Duration:** 1 week

**File Structure:**

```
src/state/produce/
â”œâ”€â”€ index.ts              # Exports
â”œâ”€â”€ produce.ts            # Main produce function
â”œâ”€â”€ produce.types.ts      # Types
â”œâ”€â”€ create-draft.ts       # Draft proxy creation
â””â”€â”€ README.md             # Documentation
```

**Implementation:**

- Immer-style mutable API
- API: `setState(produce(draft => { draft.x = 1 }))`
- Use Proxy for draft tracking
- Generate immutable result
- Handle nested mutations

**Acceptance Criteria:**

- [ ] Creates mutable draft
- [ ] Tracks all mutations
- [ ] Returns immutable result
- [ ] Handles nested mutations
- [ ] Works with arrays
- [ ] Tests pass (20+ test cases)
- [ ] Documentation with examples

---

### 5. Hash Routing ðŸŸ¡ PARTIAL

**Priority:** P1  
**Duration:** 1 week

**File Structure:**

```
src/router/hash/
â”œâ”€â”€ index.ts              # Exports
â”œâ”€â”€ hash-router.ts        # Hash mode implementation
â”œâ”€â”€ hash-history.ts       # History management
â””â”€â”€ README.md             # Documentation
```

**Implementation:**

- Hash-based routing (#/route)
- API: `<Router mode="hash" />`
- Backward compatible with existing router
- Handle hash change events
- URL parsing for hash routes

**Acceptance Criteria:**

- [ ] Routes work with # prefix
- [ ] Browser back/forward works
- [ ] No server configuration needed
- [ ] Compatible with existing router
- [ ] Tests pass (15+ test cases)
- [ ] Documentation complete

---

### 6. route.data Enhancement ðŸŸ¡ PARTIAL

**Priority:** P2  
**Duration:** 1 week

**File Structure:**

```
src/router/data/
â”œâ”€â”€ index.ts              # Exports
â”œâ”€â”€ route-data.ts         # Data loading logic
â”œâ”€â”€ route-data.types.ts   # Types
â””â”€â”€ README.md             # Documentation
```

**Implementation:**

- Data loading at route level
- Integration with resource system
- Preload before navigation
- Handle loading states

**Acceptance Criteria:**

- [ ] Data loads before route
- [ ] Shows loading state
- [ ] Error handling works
- [ ] Integrates with resources
- [ ] Tests pass (12+ test cases)
- [ ] Documentation complete

---

## Testing Strategy

**Unit Tests:**

- Each component isolated
- Edge cases covered
- Performance benchmarks

**Integration Tests:**

- Components work together
- Router integration
- State management integration

**Performance Tests:**

- Index vs For comparison
- reconcile() efficiency
- produce() overhead

## Migration Guide

**Breaking Changes:** None  
**New APIs:**

- `<Index>` component
- `<Dynamic>` component
- `reconcile()` function
- `produce()` function
- Router `mode="hash"` prop
- Route `data` property

## Documentation

- [ ] API reference for each feature
- [ ] Migration examples
- [ ] Performance comparisons
- [ ] Best practices guide
- [ ] Common patterns
